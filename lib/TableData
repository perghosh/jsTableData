/**
 *
 * */
export class CTableData {
    constructor(options) {
        const o = options || {};
        this.m_aBody = o.body || [];
        this.m_aColumn = o.column || [];
        this.m_sId = o.id || "id" + (new Date()).getUTCMilliseconds();
        this.m_iFooterSize = o.footer_size || 0;
        this.m_iHeaderSize = o.header_size || 0;
        this.m_iPage = o.page || 0;
        this.m_aDirtyRow = o.dirty_row || [];
    }
    /**
     * Append columns to table data
     * @param {unknown | unknown[]} _Column column data added to table data. if column is sent as string it is treated as column name
     * @param {((_C: unknown[], _Empty: details.column[]) => details.column[])} [convert] Callback method if columns need to reformatting to adapt to table data format
     */
    COLUMNAppend(_Column, convert) {
        let aColumn;
        // check if _Column is string, if string it is treated as a name
        if (typeof _Column === "string") {
            _Column = this._create_column(1, { id: _Column, name: _Column, position: { index: this.COLUMNGetCount() } });
        }
        if (Array.isArray(_Column) === false)
            _Column = [_Column];
        if (convert) {
            aColumn = this._create_column(_Column.length);
            aColumn = convert(_Column, aColumn);
        }
        else
            aColumn = _Column;
        this.m_aColumn = this.m_aColumn.concat(aColumn);
        return this.m_aColumn.length;
    }
    /**
     * Get column object for index or name
     * @param {number | string} _Index return column object for index or name
     * @param {boolean} [bNull]
     */
    COLUMNGet(_Index, bNull) {
        if (!bNull)
            return this._column(_Index);
        let iIndex = this._index(_Index);
        if (iIndex === -1)
            return null;
        return this.m_aColumn[iIndex];
    }
    /**
     * Count columns and return how many.
     * This can also count column with properties, like how many key columns there are.
     * The property sent is name for object property that is investigated. Some properties have child object so the syntax for finding a key is
     * "key.key". Another sample is to find position and in child object we want page. Then the property name is "position.name".
     * @param {string} [sProperty] property name, if child property remember the format is "property.property"
     * @param {string|number} [_Value] Value to compare with if specified values are counted
     */
    COLUMNGetCount(sProperty, _Value) {
        if (!sProperty)
            return this.m_aColumn.length;
        let [s0, s1] = sProperty.split("."); // format to find property is property_name.property_name because some properties are in child objects
        let iCount = 0;
        let iIndex = this.m_aColumn.length;
        this.m_aColumn.forEach(function (o) {
            let v = o[s0];
            if (s1 && v)
                v = v[s1];
            if (v !== undefined) {
                if (_Value === undefined)
                    iCount++;
                else if (v === _Value)
                    iCount++;
            }
        });
    }
    /**
     * Returns selected property value from column or columns.
     * Each column holds a number of property values. With this function you can get any of them.
     * @param {boolean}  _Index if true return property value for all columns in array
     * @param {number}   _Index index to column property is returned for, property is returned as value
     * @param {string}   _Index id or name to column property is returned for, property is returned as value
     * @param {number[]} _Index index array to columns properties is returned for, property for columns is returned as array
     * @param {string[]} _Index id or name array to columns properties is returned for, property for columns is returned as array
     * @param {string} _Property property name, if child property remember the format is "property.property"
     * @param {string[]} _Property property names, return multiple properties
     * @param {boolean} [bRaw] Index for column will use direct index in internal column array.
     */
    COLUMNGetPropertyValue(_Index, _Property, bRaw) {
        let column;
        let bArray = false;
        let bAll = false;
        let aReturn = [];
        if (typeof _Index === "boolean" || _Index === void 0) {
            bAll = true;
            bArray = true;
        } // boolean value, then take all columns
        else if (Array.isArray(_Index) === false)
            _Index = [_Index];
        else
            bArray = true;
        let iEnd = bAll ? this.m_aColumn.length : _Index.length;
        for (let i = 0; i < iEnd; i++) {
            let _Position = bAll ? i : _Index[i];
            if (bAll) {
                column = this.m_aColumn[i];
            }
            else {
                if (bRaw)
                    column = this.m_aColumn[_Position];
                else
                    column = this._column(_Position);
            }
            if (Array.isArray(_Property)) {
                let a = [];
                _Property.forEach((s) => {
                    let [s0, s1] = s.split("."); // format to find property is property_name.property_name because some properties are in child objects
                    let v = column[s0];
                    if (s1 && v)
                        v = v[s1];
                    a.push(v);
                });
                aReturn.push([_Position, a]);
            }
            else {
                let [s0, s1] = _Property.split("."); // format to find property is property_name.property_name because some properties are in child objects
                let v = column[s0];
                if (s1 && v)
                    v = v[s1];
                aReturn.push([_Position, v]);
            }
        }
        if (bArray)
            return aReturn; // return index and value for property in array
        return aReturn[0][1]; // return primitive value for property
    }
    static GetPropertyValue(aSource, _Index, _Property, _Raw) {
        let o;
        let bArray = false;
        let bAll = false;
        let aReturn = [];
        if (typeof _Index === "boolean" || _Index === void 0) {
            bAll = true;
            bArray = true;
        } // boolean value, then take all columns
        else if (Array.isArray(_Index) === false)
            _Index = [_Index];
        else
            bArray = true;
        if (Array.isArray(aSource) === false)
            aSource = [aSource];
        let iEnd = bAll ? aSource.length : _Index.length;
        for (let i = 0; i < iEnd; i++) {
            let _Position = bAll ? i : _Index[i];
            if (bAll) {
                o = aSource[i];
            }
            else {
                if (_Raw === true)
                    o = aSource[_Position];
                else
                    o = _Raw(_Position);
            }
            if (Array.isArray(_Property)) {
                let a = [];
                _Property.forEach((s) => {
                    let [s0, s1] = s.split("."); // format to find property is property_name.property_name because some properties are in child objects
                    let v = o[s0];
                    if (s1 && v)
                        v = v[s1];
                    a.push(v);
                });
                aReturn.push([_Position, a]);
            }
            else {
                let [s0, s1] = _Property.split("."); // format to find property is property_name.property_name because some properties are in child objects
                let v = o[s0];
                if (s1 && v)
                    v = v[s1];
                aReturn.push([_Position, v]);
            }
        }
        if (bArray)
            return aReturn; // return index and value for property in array
        return aReturn[0][1]; // return primitive value for property
    }
    /**
     * Set property value for column
     * @param {number|string} _Index index or name for column that you want to set
     * @param {string} _Property property name, if child property remember the format is "property.property"
     * @param {unknown} _Value value set to property
     * @param {boolean} [bRaw] Index for column will use direct index in internal column array.
     * @returns {unknown} old property value
     */
    COLUMNSetPropertyValue(_Index, _Property, _Value, bRaw) {
        let column;
        let bArray = false;
        let bAll = false;
        let aReturn = [];
        let _Old = [];
        if (typeof _Index === "boolean" || _Index === void 0) {
            bAll = true;
            bArray = true;
        } // boolean value, then take all columns
        else if (Array.isArray(_Index) === false)
            _Index = [_Index];
        else
            bArray = true;
        let iEnd = bAll ? this.m_aColumn.length : _Index.length;
        for (let i = 0; i < iEnd; i++) {
            let _Position = bAll ? i : _Index[i];
            if (bAll) {
                column = this.m_aColumn[i];
            }
            else {
                if (bRaw)
                    column = this.m_aColumn[_Position];
                else
                    column = this._column(_Position);
            }
            if (Array.isArray(_Property)) {
                _Property.forEach((s) => {
                    let [s0, s1] = s.split("."); // format to find property is property_name.property_name because some properties are in child objects
                    if (column.hasOwnProperty(s0) === false) {
                        if (typeof s1 === "string")
                            column[s0] = {};
                    }
                    if (typeof s1 === "string") {
                        _Old.push(column[s0][s1]);
                        column[s0][s1] = _Value;
                    }
                    else {
                        _Old.push(column[s0]);
                        column[s0] = _Value;
                    }
                });
            }
            else {
                let [s0, s1] = _Property.split("."); // format to find property is property_name.property_name because some properties are in child objects
                if (column.hasOwnProperty(s0) === false) {
                    if (typeof s1 === "string")
                        column[s0] = {};
                }
                if (typeof s1 === "string") {
                    _Old.push(column[s0][s1]);
                    column[s0][s1] = _Value;
                }
                else {
                    _Old.push(column[s0]);
                    column[s0] = _Value;
                }
            }
        }
        if (bArray)
            return _Old; // return index and value for property in array
        return _Old[0]; // return primitive value for property
    }
    /**
     * Get value in cell
     * @param  {number} iRow index for row in source array
     * @param  {number|string} _Column index or key to column value
     * @param  bRaw {boolean} if raw value cell value from raw row is returned
     */
    CELLGetValue(iRow, _Column, bRaw) {
        let _V;
        let [iR, iC] = this._get_cell_coords(iRow, _Column, bRaw); // iR = row index, iC = column index
        let aRow = this.m_aBody[iR];
        if (aRow[iC] instanceof Array) {
            _V = aRow[iC][0];
        }
        else {
            _V = aRow[iC];
        }
        return _V;
    }
    CELLSetValue(_Row, _Column, value, bRaw) {
        if (typeof _Row === "number") {
            let [iR, iC] = this._get_cell_coords(_Row, _Column, bRaw);
            let aRow = this.m_aBody[iR];
            if (aRow[iC] instanceof Array) { // is current value array
                if (Array.isArray(value) == false)
                    aRow[iC][0] = value; // if not value is array, then replace first value in array
                else
                    aRow[iC] = value; // value is array, replace 
            }
            else {
                aRow[iC] = value;
            } // new value to cell
        }
        else if (Array.isArray(_Row) === true) {
            let aRow; // active row
            bRaw = value; // only three arguments, fix raw
            value = _Column; // only three arguments, fix value
            let [iR1, iC1, iR2, iC2] = [..._Row]; // convert to variables
            [iR1, iC1] = this._get_cell_coords(iR1, iC1, bRaw); // get physical positions
            [iR2, iC2] = this._get_cell_coords(iR2, iC2, bRaw); // get physical positions
            if (iR1 > iR2)
                iR2 = [iR1, iR2 = iR1][0];
            if (iC1 > iC2)
                iC2 = [iC1, iC2 = iC1][0];
            for (let iR = iR1; iR <= iR2; iR++) {
                aRow = this.m_aBody[iR];
                for (let iC = iC1; iC <= iC2; iC++) {
                    if (aRow[iC] instanceof Array) {
                        if (Array.isArray(value) == false)
                            aRow[iC][0] = value;
                        else
                            aRow[iC] = value;
                    }
                    else {
                        aRow[iC] = value;
                    }
                }
            }
        }
    }
    /**
     * Is value in cell array or a primitive, if array then this return true
     * @param  {number} iRow index for row in source array
     * @param  {number|string} _Column index or key to column value
     * @param  bRaw {boolean} if raw value cell value from raw row is returned
     */
    CELLIsArray(iRow, _Column, bRaw) {
        let [iR, iC] = this._get_cell_coords(iRow, _Column, bRaw); // iR = row index, iC = column index
        let aRow = this.m_aBody[iR];
        if (aRow[iC] instanceof Array)
            return true;
        return false;
    }
    /**
     * Get number of rows in table
     * @param {boolean} [bRaw] if raw then return all rows in internal body, otherwise header and footer rows are subtracted
     */
    ROWGetCount(bRaw) {
        if (bRaw)
            return this.m_aBody.length;
        return this.m_aBody.length - this.m_iHeaderSize - this.m_iFooterSize;
    }
    /**
     * Append rows to table. Added rows will always add one more compared to number of columns. First rows holds index for row.
     * @param {number | unknown[] | unknown[][]} _Row number of rows, or array of values added to row
     * @param {boolean} [bRaw] if true then add to body without calculating position
     */
    ROWAppend(_Row, bRaw) {
        _Row = _Row || 1;
        let aRow = [];
        let iColumnCount = this.COLUMNGetCount() + 1; // OBS! One more compared to number of columns
        if (typeof _Row === "number") {
            for (let i = 0; i < _Row; i++) {
                aRow.push(new Array(iColumnCount));
            }
        }
        else {
            aRow = _Row;
            if (aRow.length === 0)
                return;
            if (Array.isArray(aRow[0]) === false)
                aRow = [aRow];
        }
        if (bRaw || this.m_iFooterSize === 0) {
            let iIndex = this.m_aBody.length;
            aRow.forEach((row) => { row[0] = iIndex; iIndex++; });
            this.m_aBody = this.m_aBody.concat(aRow);
        }
        else {
            let iPosition = this.ROWGetCount(true) - this.m_iFooterSize;
            let iIndex = this.m_aBody.length ? this.m_aBody[iPosition][0] : 0;
            for (let i = 0; i < aRow.length; i++) {
                this.m_aBody.splice(iPosition + i, 0, aRow[i]);
            }
            // Set new indexes
            let iEnd = this.m_aBody.length;
            for (let i = iIndex; i < iEnd; i++) {
                this.m_aBody[iPosition][0] = i;
            }
        }
    }
    /**
     * Expands each row in table with 1 or more columns
     * @param {number} iCount number of columns to expand
     * @param {unknown} [_Value] if expanded columns has default value
     */
    ROWExpand(iCount, _Value) {
        iCount = iCount || 1;
        let a = new Array(iCount); // array to append to each row
        if (_Value !== undefined)
            a.fill(_Value); // default value in array
        let i = this.m_aBody.length;
        while (--i >= 0) {
            for (let j = 0; j < a.length; j++)
                this.m_aBody[i].push(a[j]);
        }
    }
    /**
     * Read object data
     * @param aList
     */
    ReadObjects(aList) {
        if (Array.isArray(aList) === false)
            aList = [aList];
        if (aList.length === 0)
            return;
        // get first item
        let oFirst = aList[0];
        if (typeof aList !== "object")
            return;
        let aColumns = Object.keys(oFirst);
        aColumns.forEach((sName) => {
            if (this.COLUMNGet(sName, true) === null) {
                this.COLUMNAppend(sName);
                if (this.ROWGetCount(true) !== 0)
                    this.ROWExpand();
            }
        });
        let iRow = this.ROWGetCount() + this.m_iHeaderSize;
        let iRowCount = aList.length;
        this.ROWAppend(iRowCount);
        aList.forEach((oData) => {
            Object.entries(oData).forEach((a) => {
                this.CELLSetValue(iRow, a[0], a[1]);
            });
            iRow++;
        });
    }
    GetBody() { return this.m_aBody; }
    /**
     * Return row for index
     * @param iRow index to row
     * @param bRaw use physical index and don't copy row
     */
    GetRow(_Row, bRaw) {
        let aRow;
        let iRow = _Row;
        iRow += this.m_iHeaderSize;
        aRow = this.m_aBody[iRow];
        if (!bRaw) {
            Array.from(aRow);
            aRow.shift();
        }
        return aRow;
    }
    /**
     *
     * @param aResult
     * @param aBody
     * @param iBegin
     * @param iEnd
     * @param options
     */
    static _get_data(aResult, aBody, iBegin, iEnd, options) {
        aResult = aResult || [];
        let aHidden = options.hidden || null, aOrder = options.order, iSlice = options.slice || 1, bAddIndex = options.index || false;
        // if columns are reordered then fix array marking hidden columns
        if (aHidden && aOrder) {
            let a = [];
            aOrder.forEach((iPosition, iIndex) => { a.push(aHidden[iPosition]); });
            aHidden = a;
        }
        let iAdd = iBegin < iEnd ? 1 : -1;
        for (let iRow = iBegin; iRow !== iEnd; iRow += iAdd) {
            let aRow = aBody[iRow].slice(iSlice);
            // How reorder works
            // row = [A,B,C,D,E,F], order = [5,4,3,2,1,0,0,0]
            // create new array
            // loop order array and push value at current index to new array
            // result = [F,E,D,C,B,A,A,A]
            if (aOrder) {
                let a = [];
                aOrder.forEach((iPosition, iIndex) => { a.push(aRow[iPosition]); });
                aRow = a;
            }
            // Remove hidden values, only push those that should be displayed
            // Push values that is to be shown.
            if (aHidden) {
                let a = [];
                aHidden.forEach((iHide, iIndex) => { if (iHide !== 1)
                    a.push(aRow[iIndex]); });
                aRow = a;
            }
            // take first value if array in cell
            aRow.forEach((v, i) => { if (Array.isArray(v))
                aRow[i] = v[0]; });
            aResult.push(aRow);
        }
        return aResult;
    }
    /**
     * Return array with rows and if specified another array with row numbers
     * @param oOptions
     */
    GetData(oOptions) {
        let o = oOptions || {};
        let iPage = 0;
        let iTotalRowCount = this.ROWGetCount(true);
        let iBeginRow = this.m_iHeaderSize, iEndRow = iTotalRowCount - this.m_iFooterSize, iSlice = 1; // Important, first column in body is the index for row, default is not to add this column to result
        let aResult = [];
        iBeginRow = o.begin || iBeginRow;
        iEndRow = o.end || iEndRow;
        CTableData._get_data(aResult, this.m_aBody, iBeginRow, iEndRow, { slice: iSlice });
        return aResult;
    }
    /**
     * Check if any or selected row is dirty (dirty = values are modified)
     * @param {number} [iIndex] Index to row that is checked if dirty
     * @returns {boolean} true if row is dirty when row is specified, or if no row is specified than returns true if any row is dirty. Otherwise false
     */
    IsDirty(iIndex) {
        if (typeof iIndex === "number") {
            for (let i = 0; i < this.m_aDirtyRow.length; i++) {
                if (this.m_aDirtyRow[i] === iIndex)
                    return true;
            }
            return false;
        }
        return this.m_aDirtyRow.length > 0;
    }
    /**
     * Validate cords to be within table bounds
     * @param iR
     * @param _C
     */
    ValidateCoords(iR, _C) {
        if (typeof _C === "number") {
            return this._validate_coords(iR, _C);
        }
        else if (typeof _C === "string") {
            if (this._index(_C) === -1)
                return false;
        }
        if (iR >= this.m_aBody.length)
            return false;
        return true;
    }
    _create_column(iCount, oColumn) {
        iCount = iCount || 1;
        oColumn = oColumn || {};
        let aColumn = [];
        while (--iCount >= 0) {
            let o = {
                alias: null, extra: null, format: {}, id: null, key: {}, name: null, position: {}, simple: null, title: null, rule: {}, state: {}, type: {}, value: null
            };
            aColumn.push({ ...o, ...oColumn });
        }
        return aColumn;
    }
    /**
     * Get column object for index
     * @param {number|string} _Index index to column data returned
     */
    _column(_Index) {
        let iIndex = this._index(_Index);
        if (iIndex >= 0)
            return this.m_aColumn[iIndex];
        throw "Column for " + _Index.toString() + " not found";
    }
    /**
     * Return index to column in `m_aColumn` where column information is found
     * @param {number|string} _Index index that is converted to index in `m_aColumnIndex`
     */
    _index(_Index) {
        if (typeof _Index === "number") {
            if (!this.m_aColumnIndex)
                return _Index;
            return this.m_aColumnIndex[_Index];
        }
        else if (typeof _Index === "string") {
            let i = this.m_aColumn.length;
            while (--i >= 0) {
                if (this.m_aColumn[i].id === _Index)
                    return i;
            }
            i = this.m_aColumn.length;
            while (--i >= 0) {
                if (this.m_aColumn[i].name === _Index)
                    return i;
            }
        }
        return -1;
    }
    /**
     * Get physical coordinates for cell in body data
     * @param iRow index for row in source array
     * @param  {number|string} _Column index or key to column value
     * @param bRaw {boolean} if raw value cell value from raw row is returned
     */
    _get_cell_coords(iRow, _Column, bRaw) {
        let iR, iC;
        if (!bRaw) {
            iR = iRow + this.m_iHeaderSize;
            iC = this._index(_Column) + 1; // First column among rows has index to row
        }
        else {
            iR = iRow;
            iC = _Column; // if raw then _Column has to be a number
        }
        return [iR, iC];
    }
    _validate_coords(iR, iC) {
        if (iR < this.m_aBody.length && iC < this.m_aColumn.length)
            return true;
        return false;
    }
}
